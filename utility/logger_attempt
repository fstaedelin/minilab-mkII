import gc

from backend.dictionaries import *
global TAGLENGTH
TAGLENGTH = 100

global INITDEPTHTAG
INITDEPTHTAG = str('          ')

global WARNINGMAXDEPTH
WARNINGMAXDEPTH = 0


global DEBUGMAXDEPTH
DEBUGMAXDEPTH = 0

class Tagable:
    DEPTH = 0
    WRITING_DEPTH = 0
    
    def __init__(self, title=[], key = True, callback_fn=[], text = [], tag = ''):
        self.depth = Tagable.DEPTH
        self.depthTag = Tagable.setDepthTag()
        
        self.title = title
        self.key = key
        self.tag = tag
        self.callback_fn = callback_fn
        self.text = text
    
        self.isProcessed = False
    
        #

    def PresentezVous(self):
        print(self.depthTag, 'Creating warning of depth:', Tagable.DEPTH)
        print('length of title: ', len(self.title))
        print(self.depthTag, self.depthTag, 'With Title', self.title)
        
    def _process(self):
        self.isProcessed = True
        
    def close(self):
        self._functions()
        self._process()
        self.printSelf()
        
    def printSelf(self):
        if self.key:
            self.printTitle()
            self.printText()
        for obj in gc.get_objects():
            if issubclass(type(obj), Tagable):
                while Tagable.WRITING_DEPTH <= self.depth:
                    if obj.depth == Tagable.WRITING_DEPTH and not obj.isProcessed :
                        obj.close()

                    Tagable.WRITING_DEPTH += 1
                    if self.key:
                        self.printClose()
        
    # To be used by parent initiator ? + code setCallback
    def _setParamLists(self, inTitle, inText, in_callback_fn):
        return self.__processIncoming(self._getTitle(), inTitle), self.__processIncoming(self._getText(), inText), self.__processIncoming(self._getCallbacks(), in_callback_fn)
    
    def _getTitle(self): return self.title
    def _getText(self): return self.text
    def _getCallback(self): return self.callback_fn
    
    def __processIncoming(self, key, value):
        # key: a self._getcurrent() 
        # value: the input value
        
        # initialization:
        output: list[str] = []
        # if I have already have text,
        if key:
            #copy it
            output = key
        # test, if input text exists and is not void:
        if value:
            # as long as you are reading lists, loop through them
            if isinstance(value, list) and isinstance(value, list[not list]):
                #loop through it
                if value.callable():
                    output.append(value)
                else:
                    output.append(self._convertListToString(value))
            elif isinstance(value, str):
            # if is a string, add to new line
                output.append(value)
            elif isinstance(value, list):
                self.__processIncoming(key, value)
            else:
                raise TypeError('Unexpected input in Tagable._processIncoming(value)')
        return self._autoIndent(output)

    def _processIncomingTitle(self, title):
        output = self._getTitle()
        if title:
            output = self._autoIndent(title)
        return output
    
    

    def _convertListToString(inputList =[]):
        output = ''
        for t in inputList:
            output += str(t)
        return output
            
        
    def _functions(self):
        for fn in self.callback_fn:
            fn

    def close(self):
        self._functions()
        self._process()
        self.printSelf()

    def _autoIndent(self, text: str):
        return self.depthTag + text + self.depthTag
    
    def printTitle(self):
        print(self.depthTag + self._generateTags(self.title) + ' Opening ' + self.title + ' ' + self._generateTags(self.title) + self.depthTag)
        
    def printText(self):
        if self.text:
            for t in self.text:
                print(self.depthTag, t)
        
    def printClose(self):
        if self.title:
            print(self.depthTag + self._generateTags(' Closing ' + self.title[0]) + ' Closing ' + self.title[0] + self._generateTags( ' Closing ' + self.title[0]) + self.depthTag)
        else:
            print(self.depthTag, self._generateTags(' Closing ') + ' Closing ' + self._generateTags(' Closing '), self.depthTag)   
        
    def setDepthTag():
        global INITDEPTHTAG
        tag = ''
        for depth in range(1, Tagable.DEPTH):
            tag += INITDEPTHTAG
        return tag
    
    def IncrementClassDEPTH():
        Tagable.DEPTH += 1
    
    def DecrementClassDEPTH():
        Tagable.DEPTH -= 1
    
    def _generateTags(self, text=[]):
        fullTag = ''
        if text:
            tagIndex = 0
            while len(fullTag) < (TAGLENGTH-len(text))/2:
                fullTag = self._appendTag(fullTag, tagIndex)
                tagIndex+=1
        return fullTag
        
    def _appendTag(self, fullTag, tagIndex=0):
        return fullTag + self.tag[tagIndex % len(self.tag)]
    
    def printForeignText(text):
        print(Tagable.setDepthTag(),text)
    
    def printEvent(event):
        Tagable.printForeignText('event midiId: ' + str(event.midiId))
        Tagable.printForeignText('event status: ' + str(event.status))
        Tagable.printForeignText('event data1: ' + str(event.data1))
        Tagable.printForeignText('event data2: ' + str(event.data2))
        Tagable.printForeignText('event sysex: ' + str(event.sysex))
        
class Debug(Tagable):
    def __init__(self, title=[], key = True, callback_fn=[], text = []):
        super().__init__(['DEBUG', title[0]], ((DEBUGMAXDEPTH <= Tagable.DEPTH) and key), callback_fn, text, '#')
        self._setParamLists(title, key, text, callback_fn)


class myWarning(Debug):
    def __init__(self,  title=[], callback_fn=[], text = [], key = True):
        super().__init__('WARNING'+title, ((WARNINGMAXDEPTH <= Tagable.DEPTH) and key), callback_fn, text, '/!\\')
        self.condition = key
    
    def close(self):
        if self.condition:
            global DEBUGMAXDEPTH
            DEBUGMAXDEPTH = True
            super().close()
            DEBUGMAXDEPTH = False
        else:
            print('condition not met')
            self.printClose()
            self._process()

class DeviceWarning(myWarning):
    def __init__(self, title = '',callback_fn=[], text = []):
        super().__init__(self, 'DeviceWarning: '+title , text, callback_fn)
        self.PresentezVous()
        

class MappingWarning(myWarning):
    def __init__(self, title='', text = [], callback_fn=[]):
        super().__init__('MappingWarning: ' + title, text, callback_fn)
        self.PresentezVous()
        
class MIDIWarning(myWarning):
    def __init__(self, title='', text = [], callback_fn=[]):
        super().__init__('MIDIWarning: ' + title, text, callback_fn)
        self.PresentezVous()

class ProcessorWarning(myWarning):
    def __init__(self, title='', text = [], callback_fn=[]):
        super().__init__('ProcessorWarning: '+ title, text, callback_fn)
        self.PresentezVous()
        